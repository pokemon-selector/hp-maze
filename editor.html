<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Stage Editor (0/1 + Tiles)</title>
  <style>
    :root { --cell: 22px; --gap: 2px; }
    body{
      margin:0; padding:12px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background:#0f1115; color:#e8e8e8;
    }
    h1{ margin:0 0 10px; font-size:16px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    label{ font-size:13px; opacity:.95; }
    input[type="number"], input[type="text"]{
      padding:8px 10px; border-radius:10px; border:1px solid #2a3140;
      background:#141824; color:#fff;
    }
    input[type="number"]{ width:90px; }
    input[type="text"]{ width:220px; }
    select{
      padding:10px 10px; border-radius:12px; border:1px solid #2a3140;
      background:#141824; color:#fff; font-weight:700;
    }
    button{
      border:0; padding:10px 12px; border-radius:12px;
      background:#232833; color:#fff; font-weight:700;
    }
    button:active{ transform: translateY(1px); }
    .grid{
      display:grid;
      grid-template-columns: repeat(var(--w), var(--cell));
      gap: var(--gap);
      user-select:none;
      touch-action: manipulation;
      padding:10px;
      border-radius:14px;
      background:#121622;
      width: fit-content;
      max-width: 100%;
      overflow:auto;
    }
    .cell{
      width:var(--cell); height:var(--cell);
      display:flex; align-items:center; justify-content:center;
      border-radius:6px;
      background:#2f3643;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:14px;
      font-weight:800;
    }
    .wall{ background:#1b1f27; }
    .twoCol{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      align-items:start;
    }
    @media (min-width: 920px){
      .twoCol{ grid-template-columns: auto 1fr; }
    }
    textarea{
      width:min(820px, 100%);
      height:300px;
      padding:12px;
      border-radius:14px;
      border:1px solid #2a3140;
      background:#0b0e15;
      color:#e8e8e8;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12.5px;
      line-height:1.4;
    }
    .legend{ font-size:12px; opacity:.85; margin:0; line-height:1.5; }
    .badge{
      display:inline-flex; align-items:center; justify-content:center;
      min-width: 22px;
      padding: 2px 8px;
      border-radius: 999px;
      background:#232833;
      border:1px solid #2a3140;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-weight:800;
      font-size:12px;
    }
    .hintBox{
      padding:10px 12px;
      border:1px solid #2a3140;
      border-radius:14px;
      background:#121622;
      font-size:12px;
      opacity:.9;
      line-height:1.5;
      margin-bottom:10px;
    }
  </style>
</head>
<body>
  <h1>ステージエディタ（0/1 + タイル配置 / name・hp対応）</h1>

  <div class="row">
    <label>幅(W) <input id="w" type="number" min="3" value="10"></label>
    <label>高さ(H) <input id="h" type="number" min="3" value="10"></label>

    <label><input id="border" type="checkbox" checked> 外周を全部1にする</label>

    <label>
      配置モード
      <select id="mode">
        <option value="1">壁 (1)</option>
        <option value="0">床 (0)</option>
        <option value="P">P (開始)</option>
        <option value="G">G (ゴール)</option>
        <option value="B">B (ブロック)</option>
        <option value="K">K (鍵)</option>
        <option value="D">D (ドア)</option>
        <option value="^">^ (スパイク)</option>
      </select>
    </label>

    <button id="build">グリッド生成</button>
    <button id="clear">全消去</button>
    <button id="invert01">0/1反転</button>
    <button id="copy">出力をコピー</button>
  </div>

  <div class="row">
    <label>ステージ名 <input id="stageName" type="text" value="STAGE 1"></label>
    <label>HP <input id="stageHp" type="number" min="0" value="18"></label>
  </div>

  <div class="hintBox">
    ・クリック/ドラッグで配置（モードのタイルを置く）<br>
    ・<span class="badge">P</span> と <span class="badge">G</span> は各1つだけ（置き直すと前のは消えます）<br>
    ・出力は <code>{ name, hp, map: [...] }</code> 形式で、main.js の <code>STAGES</code> にそのまま貼れます
  </div>

  <div class="twoCol">
    <div>
      <div id="grid" class="grid" aria-label="grid"></div>
      <p class="legend">
        タイル：<span class="badge">1</span>=壁 / <span class="badge">0</span>=床 /
        <span class="badge">P</span> 開始 / <span class="badge">G</span> ゴール /
        <span class="badge">B</span> ブロック / <span class="badge">K</span> 鍵 /
        <span class="badge">D</span> ドア / <span class="badge">^</span> スパイク
      </p>
    </div>

    <div>
      <div id="warn" class="warnBox" style="display:none;"></div>
      <textarea id="out" readonly></textarea>
    </div>
  </div>

<script>
(() => {
  const elGrid = document.getElementById("grid");
  const elOut = document.getElementById("out");
  const elW = document.getElementById("w");
  const elH = document.getElementById("h");
  const elBorder = document.getElementById("border");
  const elMode = document.getElementById("mode");
  const elStageName = document.getElementById("stageName");
  const elStageHp = document.getElementById("stageHp");
  const elWarn = document.getElementById("warn");


  let W = 10, H = 10;
  let cells = []; // "0","1","P","G","B","K","D","^"

  function idx(x,y){ return y*W + x; }

  function applyBorder(){
    if (!elBorder.checked) return;
    for (let x=0;x<W;x++){
      cells[idx(x,0)] = "1";
      cells[idx(x,H-1)] = "1";
    }
    for (let y=0;y<H;y++){
      cells[idx(0,y)] = "1";
      cells[idx(W-1,y)] = "1";
    }
  }

  function escapeJsString(s){
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
  }

  function render(){
    elGrid.style.setProperty("--w", W);
    elGrid.innerHTML = "";

    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const i = idx(x,y);
        const c = cells[i];

        const box = document.createElement("div");
        box.className = "cell" + (c === "1" ? " wall" : "");
        box.dataset.i = String(i);
        box.textContent = (c === "0" || c === "1") ? "" : c;

        elGrid.appendChild(box);
      }
    }
    updateOutput();
  }

  function validateStage(){
    const hasP = cells.includes("P");
    const hasG = cells.includes("G");
  
    const msgs = [];
    if (!hasP) msgs.push("P（開始）がありません");
    if (!hasG) msgs.push("G（ゴール）がありません");
  
    if (msgs.length){
      elWarn.style.display = "block";
      elWarn.innerHTML = `<strong>警告:</strong> ${msgs.join(" / ")}<br>（このまま main.js に貼ると次へでエラーになります）`;
      return false;
    } else {
      elWarn.style.display = "none";
      elWarn.textContent = "";
      return true;
    }
  }

  
  function updateOutput(){
    const lines = [];
    for (let y=0;y<H;y++){
      let row = "";
      for (let x=0;x<W;x++){
        row += cells[idx(x,y)];
      }
      lines.push(row);
    }

    const stageName = escapeJsString(elStageName.value || "STAGE");
    const hp = parseInt(elStageHp.value, 10);
    const hpSafe = Number.isFinite(hp) ? hp : 0;

    const mapPretty = lines.map(s => `    "${s}"`).join(",\n");

    elOut.value =
`{
  name: "${stageName}",
  hp: ${hpSafe},
  map: [
${mapPretty}
  ],
},`;
 
  validateStage();

  
  }

  function build(){
    W = Math.max(3, parseInt(elW.value, 10) || 10);
    H = Math.max(3, parseInt(elH.value, 10) || 10);
    cells = Array(W*H).fill("0");
    applyBorder();
    render();
  }

  function findAndClear(char){
    const k = cells.indexOf(char);
    if (k >= 0) cells[k] = "0";
  }

  function paintCell(i, val){
    const x = i % W;
    const y = Math.floor(i / W);
    const isBorder = (x===0 || y===0 || x===W-1 || y===H-1);

    if (elBorder.checked && isBorder) {
      cells[i] = "1";
      return;
    }

    if (val === "P") findAndClear("P");
    if (val === "G") findAndClear("G");

    cells[i] = val;
  }

  // ドラッグ塗り
  let dragging = false;

  function handlePaint(target){
    const cellEl = target.closest(".cell");
    if (!cellEl) return false;
    const i = parseInt(cellEl.dataset.i, 10);
    const val = elMode.value;

    paintCell(i, val);

    const c = cells[i];
    cellEl.classList.toggle("wall", c === "1");
    cellEl.textContent = (c === "0" || c === "1") ? "" : c;

    // P/G置き直しは全描画（前のP/Gを消す）
    if (val === "P" || val === "G") render();
    else updateOutput();

    return true;
  }

  elGrid.addEventListener("pointerdown", (e) => {
    if (!handlePaint(e.target)) return;
  
    dragging = true;
  
    // ★重要：ポインタを捕まえる（指が外に出ても pointerup が取れる）
    try { elGrid.setPointerCapture(e.pointerId); } catch {}
  
    e.preventDefault();
  });
  
  elGrid.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    handlePaint(e.target);
  });
  
  // 解除系を増やす（ここが肝）
  function stopDrag(e){
    dragging = false;
    if (e && e.pointerId != null) {
      try { elGrid.releasePointerCapture(e.pointerId); } catch {}
    }
  }
  
  elGrid.addEventListener("pointerup", stopDrag);
  elGrid.addEventListener("pointercancel", stopDrag);
  elGrid.addEventListener("pointerleave", stopDrag);
  window.addEventListener("blur", () => { dragging = false; });


  document.getElementById("build").addEventListener("click", build);

  document.getElementById("clear").addEventListener("click", () => {
    cells.fill("0");
    applyBorder();
    render();
  });

  document.getElementById("invert01").addEventListener("click", () => {
    cells = cells.map(v => (v === "0" ? "1" : (v === "1" ? "0" : v)));
    applyBorder();
    render();
  });

  document.getElementById("copy").addEventListener("click", async () => {
    try{
      await navigator.clipboard.writeText(elOut.value);
      alert("コピーしました！");
    }catch{
      elOut.focus();
      elOut.select();
      document.execCommand("copy");
      alert("コピーしました！（フォールバック）");
    }
  });

  // name/hp変化で出力更新
  elStageName.addEventListener("input", updateOutput);
  elStageHp.addEventListener("input", updateOutput);

  build();
})();
</script>
</body>
</html>
